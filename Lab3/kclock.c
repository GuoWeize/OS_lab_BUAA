#include "kclock.h"

extern void set_timer();

void
kclock_init(void) {
	set_timer();
}

/* 首先向 0xb5000100 位置写入1， 其中 0xb5000000 是模拟器(gxemul) 映射实时钟的位置
偏移量为 0x100 表示来设置实时钟中断的频率， 1 则表示 1 秒钟中断1次, 如果写入 0, 表示关闭实时钟
实时钟对于 R3000 来说绑定到了 4 号中断上, 故这段代码其实主要用来触发了 4 号中断
注意这里的中断号和异常号是不一样的概念, 我们实验的异常包括中断 */

/* 一旦实时钟中断产生, 就会触发 MIPS 中断, 从而 MIPS 将 PC 指向0x80000080, 从而跳转到 .text.exc_vec3 代码段执行
对于实时钟引起的中断, 通过 text.exc_vec3 代码段的分发, 最终会调用 handle_int 函数来处理实时钟中断 */

/* 在 handle_int 判断 CP0_CAUSE 寄存器是不是对应的 4 号中断位引发的中断, 如果是, 则执行中断服务函数 timer_irq */
